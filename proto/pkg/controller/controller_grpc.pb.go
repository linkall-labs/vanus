// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: controller.proto

//go:generate mockgen -source=controller_grpc.pb.go -destination=mock_controller.go -package=controller
package controller

import (
	context "context"
	meta "github.com/vanus-labs/vanus/proto/pkg/meta"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// PingServerClient is the client API for PingServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PingServerClient interface {
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PingResponse, error)
}

type pingServerClient struct {
	cc grpc.ClientConnInterface
}

func NewPingServerClient(cc grpc.ClientConnInterface) PingServerClient {
	return &pingServerClient{cc}
}

func (c *pingServerClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PingResponse, error) {
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.PingServer/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PingServerServer is the server API for PingServer service.
// All implementations should embed UnimplementedPingServerServer
// for forward compatibility
type PingServerServer interface {
	Ping(context.Context, *emptypb.Empty) (*PingResponse, error)
}

// UnimplementedPingServerServer should be embedded to have forward compatible implementations.
type UnimplementedPingServerServer struct {
}

func (UnimplementedPingServerServer) Ping(context.Context, *emptypb.Empty) (*PingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}

// UnsafePingServerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PingServerServer will
// result in compilation errors.
type UnsafePingServerServer interface {
	mustEmbedUnimplementedPingServerServer()
}

func RegisterPingServerServer(s grpc.ServiceRegistrar, srv PingServerServer) {
	s.RegisterService(&PingServer_ServiceDesc, srv)
}

func _PingServer_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PingServerServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.PingServer/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PingServerServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// PingServer_ServiceDesc is the grpc.ServiceDesc for PingServer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PingServer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "linkall.vanus.controller.PingServer",
	HandlerType: (*PingServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _PingServer_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "controller.proto",
}

// EventBusControllerClient is the client API for EventBusController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EventBusControllerClient interface {
	// grpc -> HTTP
	CreateEventBus(ctx context.Context, in *CreateEventBusRequest, opts ...grpc.CallOption) (*meta.EventBus, error)
	CreateSystemEventBus(ctx context.Context, in *CreateEventBusRequest, opts ...grpc.CallOption) (*meta.EventBus, error)
	DeleteEventBus(ctx context.Context, in *meta.EventBus, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetEventBus(ctx context.Context, in *meta.EventBus, opts ...grpc.CallOption) (*meta.EventBus, error)
	ListEventBus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListEventbusResponse, error)
	UpdateEventBus(ctx context.Context, in *UpdateEventBusRequest, opts ...grpc.CallOption) (*meta.EventBus, error)
}

type eventBusControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewEventBusControllerClient(cc grpc.ClientConnInterface) EventBusControllerClient {
	return &eventBusControllerClient{cc}
}

func (c *eventBusControllerClient) CreateEventBus(ctx context.Context, in *CreateEventBusRequest, opts ...grpc.CallOption) (*meta.EventBus, error) {
	out := new(meta.EventBus)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.EventBusController/CreateEventBus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventBusControllerClient) CreateSystemEventBus(ctx context.Context, in *CreateEventBusRequest, opts ...grpc.CallOption) (*meta.EventBus, error) {
	out := new(meta.EventBus)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.EventBusController/CreateSystemEventBus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventBusControllerClient) DeleteEventBus(ctx context.Context, in *meta.EventBus, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.EventBusController/DeleteEventBus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventBusControllerClient) GetEventBus(ctx context.Context, in *meta.EventBus, opts ...grpc.CallOption) (*meta.EventBus, error) {
	out := new(meta.EventBus)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.EventBusController/GetEventBus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventBusControllerClient) ListEventBus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListEventbusResponse, error) {
	out := new(ListEventbusResponse)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.EventBusController/ListEventBus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventBusControllerClient) UpdateEventBus(ctx context.Context, in *UpdateEventBusRequest, opts ...grpc.CallOption) (*meta.EventBus, error) {
	out := new(meta.EventBus)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.EventBusController/UpdateEventBus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventBusControllerServer is the server API for EventBusController service.
// All implementations should embed UnimplementedEventBusControllerServer
// for forward compatibility
type EventBusControllerServer interface {
	// grpc -> HTTP
	CreateEventBus(context.Context, *CreateEventBusRequest) (*meta.EventBus, error)
	CreateSystemEventBus(context.Context, *CreateEventBusRequest) (*meta.EventBus, error)
	DeleteEventBus(context.Context, *meta.EventBus) (*emptypb.Empty, error)
	GetEventBus(context.Context, *meta.EventBus) (*meta.EventBus, error)
	ListEventBus(context.Context, *emptypb.Empty) (*ListEventbusResponse, error)
	UpdateEventBus(context.Context, *UpdateEventBusRequest) (*meta.EventBus, error)
}

// UnimplementedEventBusControllerServer should be embedded to have forward compatible implementations.
type UnimplementedEventBusControllerServer struct {
}

func (UnimplementedEventBusControllerServer) CreateEventBus(context.Context, *CreateEventBusRequest) (*meta.EventBus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateEventBus not implemented")
}
func (UnimplementedEventBusControllerServer) CreateSystemEventBus(context.Context, *CreateEventBusRequest) (*meta.EventBus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSystemEventBus not implemented")
}
func (UnimplementedEventBusControllerServer) DeleteEventBus(context.Context, *meta.EventBus) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteEventBus not implemented")
}
func (UnimplementedEventBusControllerServer) GetEventBus(context.Context, *meta.EventBus) (*meta.EventBus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEventBus not implemented")
}
func (UnimplementedEventBusControllerServer) ListEventBus(context.Context, *emptypb.Empty) (*ListEventbusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListEventBus not implemented")
}
func (UnimplementedEventBusControllerServer) UpdateEventBus(context.Context, *UpdateEventBusRequest) (*meta.EventBus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateEventBus not implemented")
}

// UnsafeEventBusControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventBusControllerServer will
// result in compilation errors.
type UnsafeEventBusControllerServer interface {
	mustEmbedUnimplementedEventBusControllerServer()
}

func RegisterEventBusControllerServer(s grpc.ServiceRegistrar, srv EventBusControllerServer) {
	s.RegisterService(&EventBusController_ServiceDesc, srv)
}

func _EventBusController_CreateEventBus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateEventBusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventBusControllerServer).CreateEventBus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.EventBusController/CreateEventBus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventBusControllerServer).CreateEventBus(ctx, req.(*CreateEventBusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventBusController_CreateSystemEventBus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateEventBusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventBusControllerServer).CreateSystemEventBus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.EventBusController/CreateSystemEventBus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventBusControllerServer).CreateSystemEventBus(ctx, req.(*CreateEventBusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventBusController_DeleteEventBus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(meta.EventBus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventBusControllerServer).DeleteEventBus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.EventBusController/DeleteEventBus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventBusControllerServer).DeleteEventBus(ctx, req.(*meta.EventBus))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventBusController_GetEventBus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(meta.EventBus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventBusControllerServer).GetEventBus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.EventBusController/GetEventBus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventBusControllerServer).GetEventBus(ctx, req.(*meta.EventBus))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventBusController_ListEventBus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventBusControllerServer).ListEventBus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.EventBusController/ListEventBus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventBusControllerServer).ListEventBus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventBusController_UpdateEventBus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateEventBusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventBusControllerServer).UpdateEventBus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.EventBusController/UpdateEventBus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventBusControllerServer).UpdateEventBus(ctx, req.(*UpdateEventBusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EventBusController_ServiceDesc is the grpc.ServiceDesc for EventBusController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventBusController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "linkall.vanus.controller.EventBusController",
	HandlerType: (*EventBusControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateEventBus",
			Handler:    _EventBusController_CreateEventBus_Handler,
		},
		{
			MethodName: "CreateSystemEventBus",
			Handler:    _EventBusController_CreateSystemEventBus_Handler,
		},
		{
			MethodName: "DeleteEventBus",
			Handler:    _EventBusController_DeleteEventBus_Handler,
		},
		{
			MethodName: "GetEventBus",
			Handler:    _EventBusController_GetEventBus_Handler,
		},
		{
			MethodName: "ListEventBus",
			Handler:    _EventBusController_ListEventBus_Handler,
		},
		{
			MethodName: "UpdateEventBus",
			Handler:    _EventBusController_UpdateEventBus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "controller.proto",
}

// EventLogControllerClient is the client API for EventLogController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EventLogControllerClient interface {
	ListSegment(ctx context.Context, in *ListSegmentRequest, opts ...grpc.CallOption) (*ListSegmentResponse, error)
	GetAppendableSegment(ctx context.Context, in *GetAppendableSegmentRequest, opts ...grpc.CallOption) (*GetAppendableSegmentResponse, error)
}

type eventLogControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewEventLogControllerClient(cc grpc.ClientConnInterface) EventLogControllerClient {
	return &eventLogControllerClient{cc}
}

func (c *eventLogControllerClient) ListSegment(ctx context.Context, in *ListSegmentRequest, opts ...grpc.CallOption) (*ListSegmentResponse, error) {
	out := new(ListSegmentResponse)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.EventLogController/ListSegment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLogControllerClient) GetAppendableSegment(ctx context.Context, in *GetAppendableSegmentRequest, opts ...grpc.CallOption) (*GetAppendableSegmentResponse, error) {
	out := new(GetAppendableSegmentResponse)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.EventLogController/GetAppendableSegment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventLogControllerServer is the server API for EventLogController service.
// All implementations should embed UnimplementedEventLogControllerServer
// for forward compatibility
type EventLogControllerServer interface {
	ListSegment(context.Context, *ListSegmentRequest) (*ListSegmentResponse, error)
	GetAppendableSegment(context.Context, *GetAppendableSegmentRequest) (*GetAppendableSegmentResponse, error)
}

// UnimplementedEventLogControllerServer should be embedded to have forward compatible implementations.
type UnimplementedEventLogControllerServer struct {
}

func (UnimplementedEventLogControllerServer) ListSegment(context.Context, *ListSegmentRequest) (*ListSegmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSegment not implemented")
}
func (UnimplementedEventLogControllerServer) GetAppendableSegment(context.Context, *GetAppendableSegmentRequest) (*GetAppendableSegmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppendableSegment not implemented")
}

// UnsafeEventLogControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventLogControllerServer will
// result in compilation errors.
type UnsafeEventLogControllerServer interface {
	mustEmbedUnimplementedEventLogControllerServer()
}

func RegisterEventLogControllerServer(s grpc.ServiceRegistrar, srv EventLogControllerServer) {
	s.RegisterService(&EventLogController_ServiceDesc, srv)
}

func _EventLogController_ListSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSegmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLogControllerServer).ListSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.EventLogController/ListSegment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLogControllerServer).ListSegment(ctx, req.(*ListSegmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLogController_GetAppendableSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppendableSegmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLogControllerServer).GetAppendableSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.EventLogController/GetAppendableSegment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLogControllerServer).GetAppendableSegment(ctx, req.(*GetAppendableSegmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EventLogController_ServiceDesc is the grpc.ServiceDesc for EventLogController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventLogController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "linkall.vanus.controller.EventLogController",
	HandlerType: (*EventLogControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListSegment",
			Handler:    _EventLogController_ListSegment_Handler,
		},
		{
			MethodName: "GetAppendableSegment",
			Handler:    _EventLogController_GetAppendableSegment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "controller.proto",
}

// SegmentControllerClient is the client API for SegmentController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SegmentControllerClient interface {
	QuerySegmentRouteInfo(ctx context.Context, in *QuerySegmentRouteInfoRequest, opts ...grpc.CallOption) (*QuerySegmentRouteInfoResponse, error)
	SegmentHeartbeat(ctx context.Context, opts ...grpc.CallOption) (SegmentController_SegmentHeartbeatClient, error)
	RegisterSegmentServer(ctx context.Context, in *RegisterSegmentServerRequest, opts ...grpc.CallOption) (*RegisterSegmentServerResponse, error)
	UnregisterSegmentServer(ctx context.Context, in *UnregisterSegmentServerRequest, opts ...grpc.CallOption) (*UnregisterSegmentServerResponse, error)
	ReportSegmentBlockIsFull(ctx context.Context, in *SegmentHeartbeatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ReportSegmentLeader(ctx context.Context, in *ReportSegmentLeaderRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type segmentControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewSegmentControllerClient(cc grpc.ClientConnInterface) SegmentControllerClient {
	return &segmentControllerClient{cc}
}

func (c *segmentControllerClient) QuerySegmentRouteInfo(ctx context.Context, in *QuerySegmentRouteInfoRequest, opts ...grpc.CallOption) (*QuerySegmentRouteInfoResponse, error) {
	out := new(QuerySegmentRouteInfoResponse)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.SegmentController/QuerySegmentRouteInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *segmentControllerClient) SegmentHeartbeat(ctx context.Context, opts ...grpc.CallOption) (SegmentController_SegmentHeartbeatClient, error) {
	stream, err := c.cc.NewStream(ctx, &SegmentController_ServiceDesc.Streams[0], "/linkall.vanus.controller.SegmentController/SegmentHeartbeat", opts...)
	if err != nil {
		return nil, err
	}
	x := &segmentControllerSegmentHeartbeatClient{stream}
	return x, nil
}

type SegmentController_SegmentHeartbeatClient interface {
	Send(*SegmentHeartbeatRequest) error
	CloseAndRecv() (*SegmentHeartbeatResponse, error)
	grpc.ClientStream
}

type segmentControllerSegmentHeartbeatClient struct {
	grpc.ClientStream
}

func (x *segmentControllerSegmentHeartbeatClient) Send(m *SegmentHeartbeatRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *segmentControllerSegmentHeartbeatClient) CloseAndRecv() (*SegmentHeartbeatResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SegmentHeartbeatResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *segmentControllerClient) RegisterSegmentServer(ctx context.Context, in *RegisterSegmentServerRequest, opts ...grpc.CallOption) (*RegisterSegmentServerResponse, error) {
	out := new(RegisterSegmentServerResponse)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.SegmentController/RegisterSegmentServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *segmentControllerClient) UnregisterSegmentServer(ctx context.Context, in *UnregisterSegmentServerRequest, opts ...grpc.CallOption) (*UnregisterSegmentServerResponse, error) {
	out := new(UnregisterSegmentServerResponse)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.SegmentController/UnregisterSegmentServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *segmentControllerClient) ReportSegmentBlockIsFull(ctx context.Context, in *SegmentHeartbeatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.SegmentController/ReportSegmentBlockIsFull", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *segmentControllerClient) ReportSegmentLeader(ctx context.Context, in *ReportSegmentLeaderRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.SegmentController/ReportSegmentLeader", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SegmentControllerServer is the server API for SegmentController service.
// All implementations should embed UnimplementedSegmentControllerServer
// for forward compatibility
type SegmentControllerServer interface {
	QuerySegmentRouteInfo(context.Context, *QuerySegmentRouteInfoRequest) (*QuerySegmentRouteInfoResponse, error)
	SegmentHeartbeat(SegmentController_SegmentHeartbeatServer) error
	RegisterSegmentServer(context.Context, *RegisterSegmentServerRequest) (*RegisterSegmentServerResponse, error)
	UnregisterSegmentServer(context.Context, *UnregisterSegmentServerRequest) (*UnregisterSegmentServerResponse, error)
	ReportSegmentBlockIsFull(context.Context, *SegmentHeartbeatRequest) (*emptypb.Empty, error)
	ReportSegmentLeader(context.Context, *ReportSegmentLeaderRequest) (*emptypb.Empty, error)
}

// UnimplementedSegmentControllerServer should be embedded to have forward compatible implementations.
type UnimplementedSegmentControllerServer struct {
}

func (UnimplementedSegmentControllerServer) QuerySegmentRouteInfo(context.Context, *QuerySegmentRouteInfoRequest) (*QuerySegmentRouteInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySegmentRouteInfo not implemented")
}
func (UnimplementedSegmentControllerServer) SegmentHeartbeat(SegmentController_SegmentHeartbeatServer) error {
	return status.Errorf(codes.Unimplemented, "method SegmentHeartbeat not implemented")
}
func (UnimplementedSegmentControllerServer) RegisterSegmentServer(context.Context, *RegisterSegmentServerRequest) (*RegisterSegmentServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterSegmentServer not implemented")
}
func (UnimplementedSegmentControllerServer) UnregisterSegmentServer(context.Context, *UnregisterSegmentServerRequest) (*UnregisterSegmentServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterSegmentServer not implemented")
}
func (UnimplementedSegmentControllerServer) ReportSegmentBlockIsFull(context.Context, *SegmentHeartbeatRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportSegmentBlockIsFull not implemented")
}
func (UnimplementedSegmentControllerServer) ReportSegmentLeader(context.Context, *ReportSegmentLeaderRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportSegmentLeader not implemented")
}

// UnsafeSegmentControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SegmentControllerServer will
// result in compilation errors.
type UnsafeSegmentControllerServer interface {
	mustEmbedUnimplementedSegmentControllerServer()
}

func RegisterSegmentControllerServer(s grpc.ServiceRegistrar, srv SegmentControllerServer) {
	s.RegisterService(&SegmentController_ServiceDesc, srv)
}

func _SegmentController_QuerySegmentRouteInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySegmentRouteInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SegmentControllerServer).QuerySegmentRouteInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.SegmentController/QuerySegmentRouteInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SegmentControllerServer).QuerySegmentRouteInfo(ctx, req.(*QuerySegmentRouteInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SegmentController_SegmentHeartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SegmentControllerServer).SegmentHeartbeat(&segmentControllerSegmentHeartbeatServer{stream})
}

type SegmentController_SegmentHeartbeatServer interface {
	SendAndClose(*SegmentHeartbeatResponse) error
	Recv() (*SegmentHeartbeatRequest, error)
	grpc.ServerStream
}

type segmentControllerSegmentHeartbeatServer struct {
	grpc.ServerStream
}

func (x *segmentControllerSegmentHeartbeatServer) SendAndClose(m *SegmentHeartbeatResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *segmentControllerSegmentHeartbeatServer) Recv() (*SegmentHeartbeatRequest, error) {
	m := new(SegmentHeartbeatRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SegmentController_RegisterSegmentServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterSegmentServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SegmentControllerServer).RegisterSegmentServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.SegmentController/RegisterSegmentServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SegmentControllerServer).RegisterSegmentServer(ctx, req.(*RegisterSegmentServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SegmentController_UnregisterSegmentServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterSegmentServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SegmentControllerServer).UnregisterSegmentServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.SegmentController/UnregisterSegmentServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SegmentControllerServer).UnregisterSegmentServer(ctx, req.(*UnregisterSegmentServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SegmentController_ReportSegmentBlockIsFull_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SegmentHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SegmentControllerServer).ReportSegmentBlockIsFull(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.SegmentController/ReportSegmentBlockIsFull",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SegmentControllerServer).ReportSegmentBlockIsFull(ctx, req.(*SegmentHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SegmentController_ReportSegmentLeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportSegmentLeaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SegmentControllerServer).ReportSegmentLeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.SegmentController/ReportSegmentLeader",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SegmentControllerServer).ReportSegmentLeader(ctx, req.(*ReportSegmentLeaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SegmentController_ServiceDesc is the grpc.ServiceDesc for SegmentController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SegmentController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "linkall.vanus.controller.SegmentController",
	HandlerType: (*SegmentControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QuerySegmentRouteInfo",
			Handler:    _SegmentController_QuerySegmentRouteInfo_Handler,
		},
		{
			MethodName: "RegisterSegmentServer",
			Handler:    _SegmentController_RegisterSegmentServer_Handler,
		},
		{
			MethodName: "UnregisterSegmentServer",
			Handler:    _SegmentController_UnregisterSegmentServer_Handler,
		},
		{
			MethodName: "ReportSegmentBlockIsFull",
			Handler:    _SegmentController_ReportSegmentBlockIsFull_Handler,
		},
		{
			MethodName: "ReportSegmentLeader",
			Handler:    _SegmentController_ReportSegmentLeader_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SegmentHeartbeat",
			Handler:       _SegmentController_SegmentHeartbeat_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "controller.proto",
}

// TriggerControllerClient is the client API for TriggerController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TriggerControllerClient interface {
	CreateSubscription(ctx context.Context, in *CreateSubscriptionRequest, opts ...grpc.CallOption) (*meta.Subscription, error)
	UpdateSubscription(ctx context.Context, in *UpdateSubscriptionRequest, opts ...grpc.CallOption) (*meta.Subscription, error)
	DeleteSubscription(ctx context.Context, in *DeleteSubscriptionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DisableSubscription(ctx context.Context, in *DisableSubscriptionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ResumeSubscription(ctx context.Context, in *ResumeSubscriptionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetSubscription(ctx context.Context, in *GetSubscriptionRequest, opts ...grpc.CallOption) (*meta.Subscription, error)
	ListSubscription(ctx context.Context, in *ListSubscriptionRequest, opts ...grpc.CallOption) (*ListSubscriptionResponse, error)
	TriggerWorkerHeartbeat(ctx context.Context, opts ...grpc.CallOption) (TriggerController_TriggerWorkerHeartbeatClient, error)
	RegisterTriggerWorker(ctx context.Context, in *RegisterTriggerWorkerRequest, opts ...grpc.CallOption) (*RegisterTriggerWorkerResponse, error)
	UnregisterTriggerWorker(ctx context.Context, in *UnregisterTriggerWorkerRequest, opts ...grpc.CallOption) (*UnregisterTriggerWorkerResponse, error)
	ResetOffsetToTimestamp(ctx context.Context, in *ResetOffsetToTimestampRequest, opts ...grpc.CallOption) (*ResetOffsetToTimestampResponse, error)
	CommitOffset(ctx context.Context, in *CommitOffsetRequest, opts ...grpc.CallOption) (*CommitOffsetResponse, error)
	SetDeadLetterEventOffset(ctx context.Context, in *SetDeadLetterEventOffsetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetDeadLetterEventOffset(ctx context.Context, in *GetDeadLetterEventOffsetRequest, opts ...grpc.CallOption) (*GetDeadLetterEventOffsetResponse, error)
}

type triggerControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewTriggerControllerClient(cc grpc.ClientConnInterface) TriggerControllerClient {
	return &triggerControllerClient{cc}
}

func (c *triggerControllerClient) CreateSubscription(ctx context.Context, in *CreateSubscriptionRequest, opts ...grpc.CallOption) (*meta.Subscription, error) {
	out := new(meta.Subscription)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.TriggerController/CreateSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) UpdateSubscription(ctx context.Context, in *UpdateSubscriptionRequest, opts ...grpc.CallOption) (*meta.Subscription, error) {
	out := new(meta.Subscription)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.TriggerController/UpdateSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) DeleteSubscription(ctx context.Context, in *DeleteSubscriptionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.TriggerController/DeleteSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) DisableSubscription(ctx context.Context, in *DisableSubscriptionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.TriggerController/DisableSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) ResumeSubscription(ctx context.Context, in *ResumeSubscriptionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.TriggerController/ResumeSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) GetSubscription(ctx context.Context, in *GetSubscriptionRequest, opts ...grpc.CallOption) (*meta.Subscription, error) {
	out := new(meta.Subscription)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.TriggerController/GetSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) ListSubscription(ctx context.Context, in *ListSubscriptionRequest, opts ...grpc.CallOption) (*ListSubscriptionResponse, error) {
	out := new(ListSubscriptionResponse)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.TriggerController/ListSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) TriggerWorkerHeartbeat(ctx context.Context, opts ...grpc.CallOption) (TriggerController_TriggerWorkerHeartbeatClient, error) {
	stream, err := c.cc.NewStream(ctx, &TriggerController_ServiceDesc.Streams[0], "/linkall.vanus.controller.TriggerController/TriggerWorkerHeartbeat", opts...)
	if err != nil {
		return nil, err
	}
	x := &triggerControllerTriggerWorkerHeartbeatClient{stream}
	return x, nil
}

type TriggerController_TriggerWorkerHeartbeatClient interface {
	Send(*TriggerWorkerHeartbeatRequest) error
	CloseAndRecv() (*TriggerWorkerHeartbeatResponse, error)
	grpc.ClientStream
}

type triggerControllerTriggerWorkerHeartbeatClient struct {
	grpc.ClientStream
}

func (x *triggerControllerTriggerWorkerHeartbeatClient) Send(m *TriggerWorkerHeartbeatRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *triggerControllerTriggerWorkerHeartbeatClient) CloseAndRecv() (*TriggerWorkerHeartbeatResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(TriggerWorkerHeartbeatResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *triggerControllerClient) RegisterTriggerWorker(ctx context.Context, in *RegisterTriggerWorkerRequest, opts ...grpc.CallOption) (*RegisterTriggerWorkerResponse, error) {
	out := new(RegisterTriggerWorkerResponse)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.TriggerController/RegisterTriggerWorker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) UnregisterTriggerWorker(ctx context.Context, in *UnregisterTriggerWorkerRequest, opts ...grpc.CallOption) (*UnregisterTriggerWorkerResponse, error) {
	out := new(UnregisterTriggerWorkerResponse)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.TriggerController/UnregisterTriggerWorker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) ResetOffsetToTimestamp(ctx context.Context, in *ResetOffsetToTimestampRequest, opts ...grpc.CallOption) (*ResetOffsetToTimestampResponse, error) {
	out := new(ResetOffsetToTimestampResponse)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.TriggerController/ResetOffsetToTimestamp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) CommitOffset(ctx context.Context, in *CommitOffsetRequest, opts ...grpc.CallOption) (*CommitOffsetResponse, error) {
	out := new(CommitOffsetResponse)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.TriggerController/CommitOffset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) SetDeadLetterEventOffset(ctx context.Context, in *SetDeadLetterEventOffsetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.TriggerController/SetDeadLetterEventOffset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerControllerClient) GetDeadLetterEventOffset(ctx context.Context, in *GetDeadLetterEventOffsetRequest, opts ...grpc.CallOption) (*GetDeadLetterEventOffsetResponse, error) {
	out := new(GetDeadLetterEventOffsetResponse)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.TriggerController/GetDeadLetterEventOffset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TriggerControllerServer is the server API for TriggerController service.
// All implementations should embed UnimplementedTriggerControllerServer
// for forward compatibility
type TriggerControllerServer interface {
	CreateSubscription(context.Context, *CreateSubscriptionRequest) (*meta.Subscription, error)
	UpdateSubscription(context.Context, *UpdateSubscriptionRequest) (*meta.Subscription, error)
	DeleteSubscription(context.Context, *DeleteSubscriptionRequest) (*emptypb.Empty, error)
	DisableSubscription(context.Context, *DisableSubscriptionRequest) (*emptypb.Empty, error)
	ResumeSubscription(context.Context, *ResumeSubscriptionRequest) (*emptypb.Empty, error)
	GetSubscription(context.Context, *GetSubscriptionRequest) (*meta.Subscription, error)
	ListSubscription(context.Context, *ListSubscriptionRequest) (*ListSubscriptionResponse, error)
	TriggerWorkerHeartbeat(TriggerController_TriggerWorkerHeartbeatServer) error
	RegisterTriggerWorker(context.Context, *RegisterTriggerWorkerRequest) (*RegisterTriggerWorkerResponse, error)
	UnregisterTriggerWorker(context.Context, *UnregisterTriggerWorkerRequest) (*UnregisterTriggerWorkerResponse, error)
	ResetOffsetToTimestamp(context.Context, *ResetOffsetToTimestampRequest) (*ResetOffsetToTimestampResponse, error)
	CommitOffset(context.Context, *CommitOffsetRequest) (*CommitOffsetResponse, error)
	SetDeadLetterEventOffset(context.Context, *SetDeadLetterEventOffsetRequest) (*emptypb.Empty, error)
	GetDeadLetterEventOffset(context.Context, *GetDeadLetterEventOffsetRequest) (*GetDeadLetterEventOffsetResponse, error)
}

// UnimplementedTriggerControllerServer should be embedded to have forward compatible implementations.
type UnimplementedTriggerControllerServer struct {
}

func (UnimplementedTriggerControllerServer) CreateSubscription(context.Context, *CreateSubscriptionRequest) (*meta.Subscription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSubscription not implemented")
}
func (UnimplementedTriggerControllerServer) UpdateSubscription(context.Context, *UpdateSubscriptionRequest) (*meta.Subscription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSubscription not implemented")
}
func (UnimplementedTriggerControllerServer) DeleteSubscription(context.Context, *DeleteSubscriptionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSubscription not implemented")
}
func (UnimplementedTriggerControllerServer) DisableSubscription(context.Context, *DisableSubscriptionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableSubscription not implemented")
}
func (UnimplementedTriggerControllerServer) ResumeSubscription(context.Context, *ResumeSubscriptionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeSubscription not implemented")
}
func (UnimplementedTriggerControllerServer) GetSubscription(context.Context, *GetSubscriptionRequest) (*meta.Subscription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubscription not implemented")
}
func (UnimplementedTriggerControllerServer) ListSubscription(context.Context, *ListSubscriptionRequest) (*ListSubscriptionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSubscription not implemented")
}
func (UnimplementedTriggerControllerServer) TriggerWorkerHeartbeat(TriggerController_TriggerWorkerHeartbeatServer) error {
	return status.Errorf(codes.Unimplemented, "method TriggerWorkerHeartbeat not implemented")
}
func (UnimplementedTriggerControllerServer) RegisterTriggerWorker(context.Context, *RegisterTriggerWorkerRequest) (*RegisterTriggerWorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterTriggerWorker not implemented")
}
func (UnimplementedTriggerControllerServer) UnregisterTriggerWorker(context.Context, *UnregisterTriggerWorkerRequest) (*UnregisterTriggerWorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterTriggerWorker not implemented")
}
func (UnimplementedTriggerControllerServer) ResetOffsetToTimestamp(context.Context, *ResetOffsetToTimestampRequest) (*ResetOffsetToTimestampResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetOffsetToTimestamp not implemented")
}
func (UnimplementedTriggerControllerServer) CommitOffset(context.Context, *CommitOffsetRequest) (*CommitOffsetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitOffset not implemented")
}
func (UnimplementedTriggerControllerServer) SetDeadLetterEventOffset(context.Context, *SetDeadLetterEventOffsetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDeadLetterEventOffset not implemented")
}
func (UnimplementedTriggerControllerServer) GetDeadLetterEventOffset(context.Context, *GetDeadLetterEventOffsetRequest) (*GetDeadLetterEventOffsetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeadLetterEventOffset not implemented")
}

// UnsafeTriggerControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TriggerControllerServer will
// result in compilation errors.
type UnsafeTriggerControllerServer interface {
	mustEmbedUnimplementedTriggerControllerServer()
}

func RegisterTriggerControllerServer(s grpc.ServiceRegistrar, srv TriggerControllerServer) {
	s.RegisterService(&TriggerController_ServiceDesc, srv)
}

func _TriggerController_CreateSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).CreateSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.TriggerController/CreateSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).CreateSubscription(ctx, req.(*CreateSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_UpdateSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).UpdateSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.TriggerController/UpdateSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).UpdateSubscription(ctx, req.(*UpdateSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_DeleteSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).DeleteSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.TriggerController/DeleteSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).DeleteSubscription(ctx, req.(*DeleteSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_DisableSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).DisableSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.TriggerController/DisableSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).DisableSubscription(ctx, req.(*DisableSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_ResumeSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).ResumeSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.TriggerController/ResumeSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).ResumeSubscription(ctx, req.(*ResumeSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_GetSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).GetSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.TriggerController/GetSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).GetSubscription(ctx, req.(*GetSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_ListSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).ListSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.TriggerController/ListSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).ListSubscription(ctx, req.(*ListSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_TriggerWorkerHeartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TriggerControllerServer).TriggerWorkerHeartbeat(&triggerControllerTriggerWorkerHeartbeatServer{stream})
}

type TriggerController_TriggerWorkerHeartbeatServer interface {
	SendAndClose(*TriggerWorkerHeartbeatResponse) error
	Recv() (*TriggerWorkerHeartbeatRequest, error)
	grpc.ServerStream
}

type triggerControllerTriggerWorkerHeartbeatServer struct {
	grpc.ServerStream
}

func (x *triggerControllerTriggerWorkerHeartbeatServer) SendAndClose(m *TriggerWorkerHeartbeatResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *triggerControllerTriggerWorkerHeartbeatServer) Recv() (*TriggerWorkerHeartbeatRequest, error) {
	m := new(TriggerWorkerHeartbeatRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TriggerController_RegisterTriggerWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterTriggerWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).RegisterTriggerWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.TriggerController/RegisterTriggerWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).RegisterTriggerWorker(ctx, req.(*RegisterTriggerWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_UnregisterTriggerWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterTriggerWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).UnregisterTriggerWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.TriggerController/UnregisterTriggerWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).UnregisterTriggerWorker(ctx, req.(*UnregisterTriggerWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_ResetOffsetToTimestamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetOffsetToTimestampRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).ResetOffsetToTimestamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.TriggerController/ResetOffsetToTimestamp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).ResetOffsetToTimestamp(ctx, req.(*ResetOffsetToTimestampRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_CommitOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).CommitOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.TriggerController/CommitOffset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).CommitOffset(ctx, req.(*CommitOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_SetDeadLetterEventOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDeadLetterEventOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).SetDeadLetterEventOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.TriggerController/SetDeadLetterEventOffset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).SetDeadLetterEventOffset(ctx, req.(*SetDeadLetterEventOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerController_GetDeadLetterEventOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDeadLetterEventOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerControllerServer).GetDeadLetterEventOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.TriggerController/GetDeadLetterEventOffset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerControllerServer).GetDeadLetterEventOffset(ctx, req.(*GetDeadLetterEventOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TriggerController_ServiceDesc is the grpc.ServiceDesc for TriggerController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TriggerController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "linkall.vanus.controller.TriggerController",
	HandlerType: (*TriggerControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSubscription",
			Handler:    _TriggerController_CreateSubscription_Handler,
		},
		{
			MethodName: "UpdateSubscription",
			Handler:    _TriggerController_UpdateSubscription_Handler,
		},
		{
			MethodName: "DeleteSubscription",
			Handler:    _TriggerController_DeleteSubscription_Handler,
		},
		{
			MethodName: "DisableSubscription",
			Handler:    _TriggerController_DisableSubscription_Handler,
		},
		{
			MethodName: "ResumeSubscription",
			Handler:    _TriggerController_ResumeSubscription_Handler,
		},
		{
			MethodName: "GetSubscription",
			Handler:    _TriggerController_GetSubscription_Handler,
		},
		{
			MethodName: "ListSubscription",
			Handler:    _TriggerController_ListSubscription_Handler,
		},
		{
			MethodName: "RegisterTriggerWorker",
			Handler:    _TriggerController_RegisterTriggerWorker_Handler,
		},
		{
			MethodName: "UnregisterTriggerWorker",
			Handler:    _TriggerController_UnregisterTriggerWorker_Handler,
		},
		{
			MethodName: "ResetOffsetToTimestamp",
			Handler:    _TriggerController_ResetOffsetToTimestamp_Handler,
		},
		{
			MethodName: "CommitOffset",
			Handler:    _TriggerController_CommitOffset_Handler,
		},
		{
			MethodName: "SetDeadLetterEventOffset",
			Handler:    _TriggerController_SetDeadLetterEventOffset_Handler,
		},
		{
			MethodName: "GetDeadLetterEventOffset",
			Handler:    _TriggerController_GetDeadLetterEventOffset_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TriggerWorkerHeartbeat",
			Handler:       _TriggerController_TriggerWorkerHeartbeat_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "controller.proto",
}

// SnowflakeControllerClient is the client API for SnowflakeController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SnowflakeControllerClient interface {
	GetClusterStartTime(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*timestamppb.Timestamp, error)
	RegisterNode(ctx context.Context, in *wrapperspb.UInt32Value, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UnregisterNode(ctx context.Context, in *wrapperspb.UInt32Value, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type snowflakeControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewSnowflakeControllerClient(cc grpc.ClientConnInterface) SnowflakeControllerClient {
	return &snowflakeControllerClient{cc}
}

func (c *snowflakeControllerClient) GetClusterStartTime(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*timestamppb.Timestamp, error) {
	out := new(timestamppb.Timestamp)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.SnowflakeController/GetClusterStartTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *snowflakeControllerClient) RegisterNode(ctx context.Context, in *wrapperspb.UInt32Value, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.SnowflakeController/RegisterNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *snowflakeControllerClient) UnregisterNode(ctx context.Context, in *wrapperspb.UInt32Value, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/linkall.vanus.controller.SnowflakeController/UnregisterNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SnowflakeControllerServer is the server API for SnowflakeController service.
// All implementations should embed UnimplementedSnowflakeControllerServer
// for forward compatibility
type SnowflakeControllerServer interface {
	GetClusterStartTime(context.Context, *emptypb.Empty) (*timestamppb.Timestamp, error)
	RegisterNode(context.Context, *wrapperspb.UInt32Value) (*emptypb.Empty, error)
	UnregisterNode(context.Context, *wrapperspb.UInt32Value) (*emptypb.Empty, error)
}

// UnimplementedSnowflakeControllerServer should be embedded to have forward compatible implementations.
type UnimplementedSnowflakeControllerServer struct {
}

func (UnimplementedSnowflakeControllerServer) GetClusterStartTime(context.Context, *emptypb.Empty) (*timestamppb.Timestamp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterStartTime not implemented")
}
func (UnimplementedSnowflakeControllerServer) RegisterNode(context.Context, *wrapperspb.UInt32Value) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterNode not implemented")
}
func (UnimplementedSnowflakeControllerServer) UnregisterNode(context.Context, *wrapperspb.UInt32Value) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterNode not implemented")
}

// UnsafeSnowflakeControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SnowflakeControllerServer will
// result in compilation errors.
type UnsafeSnowflakeControllerServer interface {
	mustEmbedUnimplementedSnowflakeControllerServer()
}

func RegisterSnowflakeControllerServer(s grpc.ServiceRegistrar, srv SnowflakeControllerServer) {
	s.RegisterService(&SnowflakeController_ServiceDesc, srv)
}

func _SnowflakeController_GetClusterStartTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnowflakeControllerServer).GetClusterStartTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.SnowflakeController/GetClusterStartTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnowflakeControllerServer).GetClusterStartTime(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SnowflakeController_RegisterNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.UInt32Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnowflakeControllerServer).RegisterNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.SnowflakeController/RegisterNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnowflakeControllerServer).RegisterNode(ctx, req.(*wrapperspb.UInt32Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _SnowflakeController_UnregisterNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.UInt32Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnowflakeControllerServer).UnregisterNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/linkall.vanus.controller.SnowflakeController/UnregisterNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnowflakeControllerServer).UnregisterNode(ctx, req.(*wrapperspb.UInt32Value))
	}
	return interceptor(ctx, in, info, handler)
}

// SnowflakeController_ServiceDesc is the grpc.ServiceDesc for SnowflakeController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SnowflakeController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "linkall.vanus.controller.SnowflakeController",
	HandlerType: (*SnowflakeControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetClusterStartTime",
			Handler:    _SnowflakeController_GetClusterStartTime_Handler,
		},
		{
			MethodName: "RegisterNode",
			Handler:    _SnowflakeController_RegisterNode_Handler,
		},
		{
			MethodName: "UnregisterNode",
			Handler:    _SnowflakeController_UnregisterNode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "controller.proto",
}
